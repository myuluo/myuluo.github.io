<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Quick_sort]]></title>
    <url>%2F2018%2F03%2F24%2Fquick-sort%2F</url>
    <content type="text"><![CDATA[快速排序的最差实践复杂度和冒泡排序是一样的都在O(N^2),它的平均时间复杂度为O(NlogN) 123456789101112131415161718192021222324252627282930313233343536373839404142#incude &lt;stdio.h&gt;int a[101],n;void quicksort(int left,int right)&#123;trueint i,j,t,temp; if(left &gt; right)truetruereturn;truetemp = a[left]; //temp中存在的就是基准数truei = left;truej = right;truewhile(i != j) &#123;truetruewhile(a[j]&gt;=temp &amp;&amp; i&lt;j) j--; while(a[i] &lt;= temp &amp;&amp; i&lt;j) i++;truetrueif(i&lt;j) &#123;truetruetruet = a[i];truetruetruea[i] = a[j]; a[j]=t; &#125;true&#125;truea[left]=a[i];truea[i]=temp;truequicksort(left,i-1);truequicksort(i+i,right);&#125;int main()&#123;trueint i,j,t; scanf("%d",&amp;n); for(i=1;i&lt;=n;i++)truetruescanf("%d",&amp;a[i]); quicksort(1,n);truefor(i=1;i&lt;=n;i++)truetrueprintf("%d",a[i]);truegetchar();truegetchar();truereturn 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[二分查找题]]></title>
    <url>%2F2018%2F03%2F23%2FFind-Peak-Element%2F</url>
    <content type="text"><![CDATA[A peak element is an element that is greater than its neighbors.Given an input array where num[i] ≠ num[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that num[-1] = num[n] = -∞. For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.123456789101112131415161718192021222324252627282930class Solution&#123;truepublic:truetrueint findPeakElement(vector&lt;int&gt;&amp; nums) &#123;truetruetrueint n = num.size();truetruetrueif(1==n)&#123;truetruetruetruereturn 0;truetruetrue&#125;truetruetruetruetruetrueint start = 0;truetruetrueint end = n-1;truetruetrueint mid = 0;truetruetruetruetruetruewhile(start&lt;=end)&#123;truetruetruetruemid = start +(end - start) / 2;truetruetruetrueif(mid == 0 || num[mid]&gt;=num[mid -1])&amp;&amp;truetruetruetrue (mid = n -1 || num[mid] &gt;= num[mid -1]))&#123;truetruetruetrue return mid;truetruetruetrue &#125; truetruetruetrue else if(mid &gt; 0 &amp;&amp; num[mid -1] &gt; num[mid]) &#123;truetruetruetrue end = mid -1;truetruetruetrue &#125; truetruetruetrue elsetruetruetruetrue &#123;truetruetruetrue start = mid + 1;truetruetruetrue &#125;truetruetrue&#125;truetruetruereturn mid;truetrue&#125;truetrueint n = num.size();&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[RSAlgorithm]]></title>
    <url>%2F2018%2F02%2F04%2FRSAlgorithm%2F</url>
    <content type="text"><![CDATA[我们可以高效地判断一个数是不是质数，我们可以高效地生成一个很大的质数，但我们却始终找不到高效的大数分解方法。 如何判定一个数是否为素数RSA的理论基础任意选两个比较大的质数，比如 19394489 和 27687937 。我们能够很容易计算出 19394489 乘以 27687937 的结果，它等于 536993389579193 ；但是，除了试除法以外，目前还没有什么本质上更有效的方法（也很难找到更有效的方法）能够把 536993389579193 迅速分解成 19394489 乘以 27687937 。这种不对称性很快便成了现代密码学的重要基础。让我们通过一个有趣的例子来看看，大数分解的困难性是如何派上用场的吧。 假如你和朋友用短信吵架，最后决定抛掷硬币来分胜负，正面表示你获胜，反面表示对方获胜。问题来了——两个人如何通过短信公平地抛掷一枚硬币？你可以让对方真的抛掷一枚硬币，然后将结果告诉你，不过前提是，你必须充分信任对方才行。在双方互不信任的情况下，还有办法模拟一枚虚拟硬币吗？在我们生活中，有一个常见的解决方法：考你一道题，比如“明天是否会下雨”、“地球的半径是多少”或者“《新华字典》第 307 页的第一个字是什么”，猜对了就算你赢，猜错了就算你输。不过，上面提到的几个问题显然都不是完全公平的。我们需要一类能快速生成的、很难出现重复的、解答不具技巧性的、猜对猜错几率均等的、具有一个确凿的答案并且知道答案后很容易验证答案正确性的问题。大数分解为我们构造难题提供了一个模板。比方说，让对方选择两个 90 位的大质数，或者三个 60 位的大质数，然后把乘积告诉你。无论是哪种情况，你都会得到一个大约有 180 位的数。你需要猜测这个数究竟是两个质数乘在一起得来的，还是三个质数乘在一起得来的。猜对了就算正面，你赢；猜错了就算反面，对方赢。宣布你的猜测后，让对方公开他原先想的那两个数或者三个数，由你来检查它们是否确实都是质数，乘起来是否等于之前给你的数。 `大数分解难题成为了 RSA 算法的理论基础。 RSA 算法概述我们可以选择两个充分大的质数 p 和 q ，并算出 n = p · q 。 接下来，算出 m = (p – 1)(q – 1) 。最后，找出两个数 e 和 d ，使得 e 乘以 d 的结果除以 m 余 1 。怎么找到这样的一对 e 和 d 呢？很简单。 首先，随便找一个和 m 互质的数（这是可以做到的，比方说，可以不断生成小于 m 的质数，直到找到一个不能整除 m 的为止），把它用作我们的 e 。 然后，求解关于 d 的方程 e · d mod m = 1 Bézout 定理将保证这样的 d 一定存在。 e 和 n 就可以作为加密钥匙公之于众， d 和 n 则是只有自己知道的解密钥匙。 任何知道公钥的人都可以利用公式 c = ae mod n 把原始数据 a 加密成一个新的数 c 私钥的持有者则可以计算 cd mod n ，恢复出原始数据 a 来. 3个算法优化点 不过这里还有个大问题： e 和 d 都是上百位的大数，怎么才能算出一个数的 e 次方或者一个数的 d 次方呢？显然不能老老实实地算那么多次乘法，不然效率实在太低了。好在，“反复平方”可以帮我们快速计算出一个数的乘方。比方说，计算 a35 相当于计算 a34 · a ，也即 (a^17)^2 · a ，也即 (a^16 · a)^2 · a，也即 ((a^8^)^2 ^· a)^2^ · a……最终简化为 ((((a^2^)^2^)^2^)^2^ · a)^2^ · a ，因而 7 次乘法操作就够了。 在简化的过程中， a 的指数以成半的速度递减，因而在最后的式子当中，所需的乘法次数也是对数级别的，计算机完全能够承受。不过，减少了运算的次数，并没有减小数的大小。 a 已经是一个数十位上百位的大数了，再拿 a 和它自己多乘几次，很快就会变成一个计算机内存无法容纳的超级大数。怎么办呢？别忘了，“反正最后都要对乘积取余，相乘之前事先对乘数取余不会对结果造成影响”，因此我们可以在运算过程中边算边取余，每做一次乘法都只取乘积除以 n 的余数。这样一来，我们的每次乘法都是两个 n 以内的数相乘了。利用这些小窍门，计算机才能在足够短的时间里完成 RSA 加密解密的过程。 RSA 算法实施起来速度较慢，因此在运算速度上的任何一点优化都是有益的。利用中国剩余定理，我们还能进一步加快运算速度。我们想要求的是 a^35^ 除以 n 的余数，而 n 是两个质数 p 和 q 的乘积。由于 p 和 q 都是质数，它们显然也就互质了。因而，如果我们知道 a^35^ 分别除以 p 和 q 的余数，也就能够反推出它除以 n 的余数了。因此，在反复平方的过程中，我们只需要保留所得的结果除以 p 的余数和除以 q 的余数即可，运算时的数字规模进一步降低到了 p 和 q 所在的数量级上。到最后，我们再借助“今有物，不知其数”的求解思路，把这两条余数信息恢复成一个 n 以内的数。更神的是，别忘了， a^i^ 除以 p 的余数是以 p – 1 为周期的，因此为了计算 a^35^ mod p ，我们只需要计算a^(35 mod (p-1) )^mod p就可以了。类似地，由于余数的周期性现象，计算 a^35^ mod q 就相当于计算 a^(35 mod (q-1) )^mod q 。这样一来，连指数的数量级也减小到了和 p 、 q 相同的水平， RSA 运算的速度会有明显的提升。 中国余数定理给出m个两两互质的整数，他们的乘积是P;假如有一个未知数M,如果我们已知M的分别除以这m个数所得的余数，那么在0到P-1的范围内，我们可以唯一的确定这个M。这可以看作是M的一个特解.其他所有满足要求的M，则正好是那些除以P之后余数等于这个特解的数.注意，除数互质的条件是必须的，否则结论不成立，比如在0到7之间，除以4余1并且除以2也余1的数有2个， 辗转相除递归除数除以余数，直到除尽为止那么最后一个余数就是前面所有除数和被除数的最小公约数]]></content>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow]]></title>
    <url>%2F2018%2F02%2F04%2Ftensorflow%2F</url>
    <content type="text"><![CDATA[说点什么ArXiv.org是一个托管了来自计算机科学，数学，物理学和生物学等领域的许多研究论文的在线库。下面编写一个一句给定搜索查询，从ArXiv获取摘要的类。12345678910111213141516171819202122import requestsimport osform bs4 import BeautifulSoupclass ArxivAbsgtracts:truedef __init__(self,cache_dir,categories,keywords,amount=None):truetruepasstruetruedef _fetch_all(self, amount):truetruepasstruetruedef_fetch_page(self,amount,offest):truetruepasstruetruedef _fetch_count(self):truetruepasstruetruetruedef _fetch_count(self):truetruepasstruetruetruedef _build_url(self, amount, offset):truetruepass]]></content>
  </entry>
  <entry>
    <title><![CDATA[ReinforcementLearningAnIntroduction]]></title>
    <url>%2F2018%2F02%2F03%2FReinforcementLearningAnIntroduction%2F</url>
    <content type="text"><![CDATA[强化学习的一些资料整理 Reinforcement Learning强化学习教父 Richard Sutton 的经典教材《Reinforcement Learning：An Introduction》第二版公布啦。本书分为三大部分，共十七章，机器之心对其简介和框架做了扼要介绍，并附上了全书目录、课程代码与资料。 书籍百度网盘 原书籍地址 课程代码地址 课程资料地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[bitcionAboutSites]]></title>
    <url>%2F2018%2F02%2F03%2FbitcionAboutSites%2F</url>
    <content type="text"><![CDATA[记录一些很好的文章，见解独到，描述准确把比特币为什么要使用地址说的很清楚 为什么比特币地址不直接使用公钥，而需要通过哈希生成？为什么每次付款都应该设置找零地址？一笔交易需要提供： 我的公钥 接收方的地址 我的地址 我的另一个找零钱包的地址 交易明细 对以上数据的签名 我们知道，每个人的比特别钱包中有多个比特币地址，每个比特币地址代表一定数量的比特币。 而比特币地址是通过一个公钥通过哈希（RPIEMD+SHA）生成的，这个公钥又是由私钥通过椭圆曲线（ECC）生成的。 私钥保存在比特币钱包中，不应泄露出去。而公钥在付款交易时，需要和比特币地址一起，通过交易记录公开发布，由区块链系统验证付款交易的有效性。 每次付款，我的付款比特币地址（MyBitcoinAddr）都作废了，而钱分别转移到收款人她的比特币地址（HerBitcoinAddr）中，和我自己的找零地址（MyBitcoinAddr2）中。 因为HerBitcoinAddr和MyBitcoinAddr2都从未付过款、公钥都从未公开过，所以，即使量子计算时代降临，这两个比特币地址中的钱还都是安全的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SmartPointer]]></title>
    <url>%2F2018%2F02%2F03%2F2018-02-03-smartPointer%2F</url>
    <content type="text"><![CDATA[C++的垃圾回收机制靠智能指针来实现 而在C++中，指针有两个头痛的问题，一是忘记释放动态申请的对象从而造成内存泄露；二是对象在一个地方释放后，又在别的地方被使用，从而引起内存访问错误。而android中有智能指针，可以动态的自动释放内存(类似JAVA的垃圾回收)，这样就不需要再调用delete来释放对象了，android智能指针类型就分为强指针与弱指针 C++11的智能指针在C++98中，智能指针通过一个模版类型“auto_ptr”来实现。auto_ptr以对象的方式管理堆分配的内存，并在适当的时间（比如析构），释放所获得的堆内存。这种堆内存管理的方式只需要程序员将new操作返回的指针作为auto_ptr的初始值即可，程序员不用再显式的调用delete。比如： auto_ptr(new int); 这在一定程度上避免了堆内存忘记释放而造成的问题。不过auto_ptr有一些缺点（拷贝时返回一个左值，不能调用delete[]等），所以在C++11标准中被废弃了。C++11标准中改用unique_ptr、shared_ptr及weak_ptr等智能指针来自动回收堆分配的对象。 我们来看一个C++11中使用新的智能指针的例子： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std; int main()&#123;trueunique_ptr&lt;int&gt; up1(new int(11)); //无法复制的unique_ptr// unique_ptr&lt;int&gt; up2 = up1; //不能通过编译truecout&lt;&lt;*up1&lt;&lt;endl; //11truetrueunique_ptr&lt;int&gt; up3 = move(up1); //现在up3是数据唯一的unique_ptr智能指针 truecout&lt;&lt;*up3&lt;&lt;endl; //11// cout&lt;&lt;*up1&lt;&lt;endl; //运行时错误 trueup3.reset(); //显式释放内存trueup1.reset(); //不会导致运行时错误// cout&lt;&lt;*up3&lt;&lt;endl; //运行时错误 true//不能写成shared_ptr&lt;int&gt; sp1 = new int(22); true//否则会报错：error C2440: “初始化”: 无法从“int *”转换为“std::tr1::shared_ptr&lt;_Ty&gt;”trueshared_ptr&lt;int&gt; sp1(new int(22)); trueshared_ptr&lt;int&gt; sp2 = sp1; truecout&lt;&lt;*sp1&lt;&lt;endl; //22truecout&lt;&lt;*sp2&lt;&lt;endl; //22 truesp1.reset();truecout&lt;&lt;*sp2&lt;&lt;endl; //22truetruereturn 0;&#125; 在上面的代码中，使用了两种不同的智能指针 unique_ptr 及 shared_ptr 来自动的释放堆对象的内存。由于每个智能指针都重载了运算符，用户可以使用 up1 这样的方式来访问所分配的堆内存。而在该指针析构或者调用 reset 成员的时候，智能指针都可能释放其拥有的堆内存。从作用上来讲，unique_ptr 和 shared_ptr 还是和以前的 auto_ptr 保持了一致。 不过从上述代码还是可以看到，unique_ptr 和 shared_ptr 在对所占内存的共享上还是有一定的区别的。 直观来看，unique_ptr 形如其名地，与所指对象的内存绑定紧密，不能与其他 unique_ptr 类型的指针对象共享所指对象的内存。比如，上例中的unique_ptr up2 = up1; 不能通过编译，是因为每个 unique_ptr 都是唯一地“拥有”所指向的对象内存，由于 up1 唯一地占有 new 分配的堆内存，所以 up2 无法共享其“所有权”。事实上，这种“所有权”仅能够通过标准库的 move函数 来转移。我们可以看到代码中 up3 的定义，unique_ptr up3 = move(up1); 一旦“所有权”转移成功了，原来的 unique_ptr 指针就失去了对象内存的所有权。此时再使用已经“失势”的 unique_ptr，就会导致运行时错误。上例中的后段使用 *up1 就是很好的例子。 而从实现上讲，unique_ptr 则是一个删除了拷贝构造函数、保留了移动构造函数的指针封装类型。程序员仅可以使用右值对 unique_ptr 对象进行构造，而且一旦构造成功，右值对象中的指针即被“窃取”，因此该右值对象即刻失去了对指针的“所有权”。 而 shared_ptr 同样形如其名，允许多个该智能指针共享的“拥有”同一堆分配对象的内存。与 unique_ptr 不同的是，由于在实现上采用了引用计数，所以一旦一个 shared_ptr 指针放弃了“所有权”（失效），其他的 shared_ptr 对对象内存的引用并不会受到影响。上述代码中，智能指针 sp2 就很好的说明了这种状况。虽然 sp1 调用了 reset 成员函数，但由于 sp1 和 sp2 共享了 new 分配的堆内存，所以 sp1 调用 reset 成员函数只会导致引用计数的降低，而不会导致堆内存的释放。只有在引用计数归零的时候，shared_ptr 才会真正释放所占有的堆内存的空间。 在C++11标准中，除了unique_ptr 和 shared_ptr，智能指针还包括了 weak_ptr 这个类模板。weak_ptr 的使用更为复杂一点，它可以指向 shared_ptr 指针指向的对象内存，却并不拥有该内存。而使用 weak_ptr 成员 lock，则可返回其指向内存的一个 shared_ptr 对象，且在所指对象内存已经无效时，返回指针空值（nullptr）。这在验证shared_ptr智能指针的有效性上会很有作用，看下例： 12345678910111213141516171819202122232425262728293031323334#include &lt;memory&gt;#include &lt;iostream&gt;using namespace std;void Check(weak_ptr&lt;int&gt; &amp;wp)&#123;trueshared_ptr&lt;int&gt; sp = wp.lock(); //转换为shared_ptr&lt;int&gt;trueif (sp != nullptr)true&#123;truetruecout&lt;&lt;"still " &lt;&lt; *sp &lt;&lt;endl;true&#125;elsetruetruecout&lt;&lt; "pointer is invalid."&lt;&lt;endl;&#125;int main()&#123;trueshared_ptr&lt;int&gt; sp1(new int(22));trueshared_ptr&lt;int&gt; sp2 = sp1; //指向shared_ptr&lt;int&gt; 所指对象trueweak_ptr&lt;int&gt; wp = sp1; //指向shared_ptr&lt;int&gt;所指对象truecout&lt;&lt;*sp1&lt;&lt;endl; //22truecout&lt;&lt;*sp2&lt;&lt;endl; //22trueCheck(wp); //still 22truesp1.reset();truecout&lt;&lt;*sp2&lt;&lt;endl; //22trueCheck(wp); //still 22truesp2.reset();trueCheck(wp); //pointer is invalidtruereturn 0;&#125; 在此代码中，我们定义了一个共享对象内存的两个 shared_ptr ——sp1 及 sp2。而 weak_ptr wp 同样指向该对象内存。可以看到，在 sp1 及 sp2 都有效的时候，我们调用 wp 的 lock函数，将返回一个有效的 shared_ptr 对象供试用，于是 Check函数 会输出以下内容：still 22 此后我们分别调用了 sp1 及 sp2 的 reset函数，这会导致对唯一的堆内存对象的引用计数降至0。而一旦引用计数归0，shared_ptr就会释放堆内存空间，使之失效。此时我们再调用 weak_ptr 的 lock 函数时，则返回一个指针空值nullptr。这是 Check函数 则会打印出：pointer is invalid这样的语句了。在整个过程中，只有 shared_ptr 参与了引用计数，而 weak_ptr 没有影响其指向的内存的引用计数。因此可以验证 shared_ptr 指针的有效性。 简单情况下，程序员用 unique_ptr 代替以前使用 auto_ptr 的代码就可以使用 C++11 中的智能指针了。而 shared_ptr 及 weak_ptr 则可用在用户需要引用计数的地方。 ## Ａndroid的智能指针 实现原理 android智能指针类型就分为强指针与弱指针. android中sp为强指针(sp==IServiceManager*),wp为弱指针。 强指针是通过引用计数来记录有多少使用者在使用一个对象，如果所有使用者都放弃了对该对象的引用，则该对象将被自动销毁； 而弱指针也指向一个对象，但是弱指针仅仅记录该对象的地址，不能通过弱指针来访问该对象，要想访问弱指针所指向的对象，需首先将弱指针升级为强指针（通过wp类所提供的promote()方法）。 弱指针所指向的对象是有可能在其它地方被销毁的，如果对象已经被销毁，wp的promote()方法将返回空指针，这样就能避免出现地址访问错的情况。 也就是说对象本身会增加一个弱引用计数，同时WP还包含m_ref指针，用于wp升级为sp时使用。 事实上我们对wp的唯一操作就是将其升级为sp,然后判断升级成不成功，如果成功说明该对象存在，如果不成功说明该对象已经释放掉了。 使用步骤 加入有个类MyClass,需要使用智能指针来引用这个类对象，则该类满足两个条件： 此类必须是RefBase的子类或间接子类 此类必须定义虚拟构造函数，如：virtual ～MyClass(); 满足条件后，普通指针定义：MyClass p_obj; 智能指针定义：spp_obj;(注意不是sp p_obj,牢记sp就约等同于MyClass*) 。 定义指针变量后，就可以像普通指针一样进行对变量的操作了。如：p_obj=newMyClass();// 注意不要写成p_obj=newspp_obj-&gt;func(); + 用完以后不要delete，因为智能指针会自动帮你销毁掉，用完一个对象后，只需要p_obj=NULL; 即可． + 上面是定义一个sp，而定义一个wp并进行操作呢． wp&lt;MyClass&gt;wp_obj=newMyClass(); p_obj=wp_obj.promote();// 升级为强指针。不过这里要用.而不是-&gt;、 p_obj-&gt;func(); wp_obj=NULL; + 说明：如果是第一次引用sp&lt;MyClass&gt;对象，则会调用MyClass的onFirstRef方法。]]></content>
      <categories>
        <category>program language</category>
      </categories>
      <tags>
        <tag>C++11 SmartPointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My_resume_inform_detailed]]></title>
    <url>%2F2018%2F02%2F03%2F2018-02-03-my-resume-inform-detailed%2F</url>
    <content type="text"><![CDATA[说点什么]]></content>
  </entry>
  <entry>
    <title><![CDATA[手机解锁方案]]></title>
    <url>%2F2018%2F02%2F01%2F2018-02-01-AuthToken%2F</url>
    <content type="text"><![CDATA[你是谁?怎么证明你是你,而不是别人冒充的?如果有人企图冒充你,我将让你的痕迹永远消失! Gatekeeper architecture GateKeeper daemon C++ binder service 包含平台独立的逻辑和相应的GateKeeperService java 接口. GateKeeper HAL API 一个libhardware API 借口和实现模块 Hardware GateKeeper 是GateKeeper HAL API的基于TEE的实现 LockSettingsService 会通过 Binder 发出一个请求，该请求会到达 Android 操作系统中的 gatekeeperd 守护进程。gatekeeperd 守护进程会发出一个请求，该请求会到达此守护进程在 TEE 中的副本 (Gatekeeper)。GateKeeper 进行身份验证的概要数据流程 gatekeeperd 守护进程会向 Android 框架 API 授予访问 HAL 的权限，并且会参与向 Keystore 报告设备身份验证的活动。 gatekeeperd 守护进程会在自己的进程中运行，与系统服务器隔离开来。 什么是SIDSID是一个随机生成一个 64 位数.是由TEE在用户注册新的凭据时生成的. 在设备恢复出厂设置后首次启动时，所有身份验证程序均会做好接受用户通过凭据注册的准备。用户必须先通过 Gatekeeper 注册一个 PIN 码/解锁图案/密码。该首次注册会随机生成一个 64 位的用户 SID（用户安全标识符），该用户 SID 将用作用户的标识符以及用户加密材料的绑定令牌。该用户 SID 会以加密形式绑定到用户的密码，成功通过 Gatekeeper 的身份验证后，会相应生成 AuthToken，其中包含用于该密码的用户 SID。 每当用户注册新密码时，如果未提供之前的密码，系统就会使用加密伪随机数生成器 (PRNG) 生成一个用户 SID。这称为“不可信”重新注册，在正常情况下，Android 框架不允许进行这种操作。如果用户提供了之前的有效密码，便会发生“可信”重新注册；在这种情况下，用户 SID 会迁移到新密码句柄，从而保留绑定到它的密钥。 注册密码时，用户 SID 会随密码句柄中的密码一起接受 HMAC 处理。 用户 SID 会写入到 verify 函数返回的 AuthToken 中，并且会同所有与身份验证绑定的 Keystore 密钥相关联（要详细了解 AuthToken 格式和 Keystore，请参阅身份验证）。由于对 enroll 函数的不可信调用会更改用户 SID，因此此类调用会使绑定到相应密码的密钥无法再使用。攻击者在控制 Android 操作系统后可以更改设备密码，但在此过程中，他们需要破坏掉受 Root 保护的敏感密钥。 AuthToken AuthToken 是在用户被验证时候,由Gatekeeper创建的. gatekeeper ,fringerprint,keymaster在TEE中共享的HMAC key 用来签名 AuthToken.每次重启,创建一个新的Key,来避免重放攻击. 时间戳是用来确认自设备启动到用户最后一次被认证的时间和防止AuthToken的重放攻击. 域 类型 必需 说明 AuthToken Version 1byte 是 下方所有字段的组代码。 Challenge 64bit unsigned integer 否 用于防范重播攻击的随机整数，通常是所请求的加密操作的 ID。目前由交易指纹授权使用。如果质询存在，AuthToken 将仅对包含该相同质询的加密操作有效。 User SID 64bit unsigned integer 是 不重复的用户标识符，以加密形式绑定到与设备身份验证关联的所有密钥. Authenticator ID 64bit unsigned integer,按网络字节序保存 否 绑定到特定身份验证程序政策时使用的标识符。所有身份验证程序都有自己的 ASID 值，它们可以根据自己的要求更改该值。 Authenticator Type 64bit unsigned integer,按网络字节序保存 是 0x00 代表 Gatekeeper, 0x01 代表 Fingerprint Timestamp 64bit unsigned integer,按网络字节序保存 是 自最近一次系统启动以来已经过的时间（以毫秒为单位） AuthToken HMAC(SHA-256) 256-bit blob 是 除 HMAC 字段以外所有字段的已加密 SHA-256 MAC。 AuthToken HMAC每次设备启动时，都必须生成 AuthToken HMAC 密钥并由所有 TEE 组件（Gatekeeper、Fingerprint 和 Keymaster）共用该密钥。因此，为了加强对重播攻击的防范力度，每次设备重新启动时都必须随机生成 HMAC 密钥。 关于与所有组件共用此 HMAC 密钥的协议是一项依赖于平台的实现功能。在任何情况下都不能将该密钥设为在 TEE 之外可用。如果 TEE 操作系统缺少内部进程间通信 (IPC) 机制，需要通过不可信操作系统传输数据，那么传输操作必须通过安全的密钥交换协议进行。 如何从keymaster获取AuthToken key 在HAL Open的时候,Keymaster TA通过CA APIs被打开.Keymaster TA的名字是keymaster 指纹HAL通过requset和response结构体,发送KEYMASTER_GET_AUTH_TOKEN_KEY命令给Keymaster TA. 身份验证流程 用户提供 PIN 码、解锁图案、密码或指纹。LockSettingsService 或 FingerprintService 通过 Binder 向相应的守护进程（gatekeeperd 或 fingerprintd）发出请求。指纹身份验证在指纹请求发出后异步进行。 守护进程将数据发至其副本，后者生成 AuthToken： 对于 PIN 码/解锁图案/密码身份验证，gatekeeperd 将 PIN 码、解锁图案或密码哈希发送到 TEE 中的 Gatekeeper。如果 TEE 中的身份验证成功，TEE 中的 Gatekeeper 会将包含相应用户 SID（已使用 AuthToken HMAC 密钥签名）的 AuthToken 发送到它在 Android 操作系统中的副本。 对于指纹身份验证，fingerprintd 会监听指纹事件并将数据发送到 TEE 中的 Fingerprint。如果 TEE 中的身份验证成功，TEE 中的 Fingerprint 会将 AuthToken（已使用 AuthToken HMAC 密钥签名）发送到它在 Android 操作系统中的副本。 守护进程收到经过签名的 AuthToken，并通过 Keystore 服务 Binder 接口的扩展程序将 AuthToken 传递给 Keystore 服务。 （gatekeeperd 还会在设备被重新锁定以及设备密码发生变化时通知 Keystore 服务。） Keystore 服务将 AuthToken 传递给 Keymaster，以便使用与 Gatekeeper 和 Fingerprint Trustlet 共用的密钥验证 AuthToken。Keymaster 会将令牌中的时间戳视为最后一次身份验证的时间，并根据该时间戳做出密钥发布决定（以允许应用使用相应密钥）。 错误请求次数限制验证PIN和password的失败次数和对应延迟验证的关系如下: [1, 4] = 0 sec [5] = 30 sec [6, 9] = 0 sec [10, 30] = 30 sec [31, 140] = (30 (2 ^ ((x - 30) / 10))) 1000 sec [141, inf] = 1 day GateKeeper 必须能够安全地限制对用户凭据进行暴力破解的尝试次数。如 hardware/libhardware/include/hardware/gatekeeper.h 中所示，HAL 能够返回一个超时（以毫秒数计）。超时旨在通知客户端在超时过去之前不要再次调用 GateKeeper；如果有待处理的超时，GateKeeper 不应处理相关请求。 Gatekeeper 必须先编写一个失败计数器，然后再验证用户密码。如果密码验证成功，则应清除失败计数器。这可以在发出 verify 调用后防止攻击者发起以下攻击：通过停用嵌入式 MMC (eMMC) 来阻止请求次数限制。此外，enroll 函数还会验证用户密码（如果提供了），并且必须以同样的方式对其加以限制。 如果设备支持，强烈建议将失败计数器写入到安全存储空间。如果设备不支持文件级加密，或如果安全存储空间的速度过慢，实现可以直接使用 Replay Protected Memory Block (RPMB)。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>gatekeeper keymaster keystore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TLS协议解读]]></title>
    <url>%2F2018%2F01%2F31%2F1%2F</url>
    <content type="text"><![CDATA[1.如何验证服务器证书的合法性？2.为什么要用3个随机书生成交换密钥， TLS有三个子协议，他们被用作节点对记录的安全参数取得一致，去验证他们他们自己，去实例化协商的安全参数，去互相报告错误状态握手协议负责协商一个会话，这个会话由下面几项组成： 会话标识符 节点证书 压缩方法 密码参数指定随机数函数用作生成密钥材料，大块数据加密算法（例如空，AES,等等）和MAC算法（像HMAC_SHA1）。它也定义了密码学属性，像mac长度。 主密钥 是可恢复的这个标志指示会话能被用作初始化新的连接 交换密钥参数协议 在client和server端共享的48字节密钥 TLS 握手协议### 一篇不错的关于TLS的文档 源引dog250不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。 对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。 pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android HIDL－快速消息队列]]></title>
    <url>%2F2018%2F01%2F30%2FFastMessageQueue%2F</url>
    <content type="text"><![CDATA[Binder机制效率低下，Android HIDL使用FMQ和共享内存来通讯 HIDL 的远程过程调用 (RPC) 基础架构使用 Binder 机制，这意味着调用涉及开销、需要内核操作，并且可以触发调度程序操作。不过，对于必须在开销较小且无内核参与的进程之间传输数据的情况，则使用快速消息队列 (FMQ) 系统。 FMQ 会创建具有所需属性的消息队列。MQDescriptorSync 或 MQDescriptorUnsync 对象可通过 HIDL RPC 调用发送，并可供接收进程用于访问消息队列。 MessageQueue 类型Android 支持两种队列类型（称为“风格”）： 未同步队列：可以溢出，并且可以有多个读取器；每个读取器都必须及时读取数据，否则数据将会丢失。 已同步队列：不能溢出，并且只能有一个读取器。 这两种队列都不能下溢（从空队列进行读取将会失败），并且只能有一个写入器。 未同步未同步队列只有一个写入器，但可以有任意多个读取器。此类队列有一个写入位置；不过，每个读取器都会跟踪各自的独立读取位置。 对此类队列执行写入操作一定会成功（不会检查是否出现溢出情况），但前提是写入的内容不超出配置的队列容量（如果写入的内容超出队列容量，则操作会立即失败）。由于各个读取器的读取位置可能不同，因此每当新的写入操作需要空间时，系统都允许数据离开队列，而无需等待每个读取器读取每条数据。 读取操作负责在数据离开队列末尾之前对其进行检索。如果读取操作尝试读取的数据超出可用数据量，则该操作要么立即失败（如果非阻塞），要么等到有足够多的可用数据时（如果阻塞）。如果读取操作尝试读取的数据超出队列容量，则读取一定会立即失败。 如果某个读取器的读取速度无法跟上写入器的写入速度，则写入的数据量和该读取器尚未读取的数据量加在一起会超出队列容量，这会导致下一次读取不会返回数据；相反，该读取操作会将读取器的读取位置重置为等于最新的写入位置，然后返回失败。如果在发生溢出后但在下一次读取之前，系统查看可供读取的数据，则会显示可供读取的数据超出了队列容量，这表示发生了溢出。（如果队列溢出发生在系统查看可用数据和尝试读取这些数据之间，则溢出的唯一表征就是读取操作失败。） 设置 FMQ一个消息队列需要多个 MessageQueue 对象：一个对象用作数据写入目标位置，以及一个或多个对象用作数据读取来源。没有关于哪些对象用于写入数据或读取数据的显式配置；用户需负责确保没有对象既用于读取数据又用于写入数据，也就是说最多只有一个写入器，并且对于已同步队列，最多只有一个读取器。’ 创建第一个 MessageQueue 对象通过单个调用创建并配置消息队列：123456789101112131415#include &lt;fmq/MessageQueue.h&gt;using android::hardware::kSynchronizedReadWrite;using android::hardware::kUnsynchronizedWrite;using android::hardware::MQDescriptorSync;using android::hardware::MQDescriptorUnsync;using android::hardware::MessageQueue;....// For a synchronized non-blocking FMQmFmqSynchronized = new (std::nothrow) MessageQueue&lt;uint16_t, kSynchronizedReadWrite&gt; (kNumElementsInQueue);// For an unsynchronized FMQ that supports blockingmFmqUnsynchronizedBlocking = new (std::nothrow) MessageQueue&lt;uint16_t, kUnsynchronizedWrite&gt; (kNumElementsInQueue, true /* enable blocking operations */); MessageQueue(numElements) 初始化程序负责创建并初始化支持消息队列功能的对象。 MessageQueue(numElements, configureEventFlagWord) 初始化程序负责创建并初始化支持消息队列功能和阻塞的对象。 flavor 可以是 kSynchronizedReadWrite（对于已同步队列）或 kUnsynchronizedWrite（对于未同步队列）。 uint16_t（在本示例中）可以是任意不涉及嵌套式缓冲区（无 string 或 vec 类型）、句柄或接口的 HIDL 定义的类型。 kNumElementsInQueue 表示队列的大小（以条目数表示）；它用于确定将为队列分配的共享内存缓冲区的大小。 创建第二个 MessageQueue 对象使用从消息队列的第一侧获取的 MQDescriptor 对象创建消息队列的第二侧。通过 HIDL RPC 调用将 MQDescriptor 对象发送到将容纳消息队列末端的进程。MQDescriptor 包含该队列的相关信息，其中包括： 用于映射缓冲区和写入指针的信息。 用于映射读取指针的信息（如果队列已同步）。 用于映射事件标记字词的信息（如果队列是阻塞队列）。 对象类型 ()，其中包含 HIDL 定义的队列元素类型和队列风格（已同步或未同步）。 MQDescriptor 对象可用于构建 MessageQueue 对象： 1MessageQueue&lt;T, flavor&gt;::MessageQueue(const MQDescriptor&lt;T, flavor&gt;&amp; Desc, bool resetPointers) resetPointers 参数表示是否在创建此 MessageQueue 对象时将读取和写入位置重置为 0。在未同步队列中，读取位置（在未同步队列中，是每个 MessageQueue 对象的本地位置）在此对象创建过程中始终设为 0。通常，MQDescriptor 是在创建第一个消息队列对象过程中初始化的。要对共享内存进行额外的控制，您可以手动设置 MQDescriptor（MQDescriptor 是在 system/libhidl/base/include/hidl/MQDescriptor.h 中定义的），然后按照本部分所述内容创建每个 MessageQueue 对象。 MQDescriptor.h内容如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235/* * Copyright (C) 2016 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */#ifndef _FMSGQ_DESCRIPTOR_H#define _FMSGQ_DESCRIPTOR_H#include &lt;unistd.h&gt;#include &lt;cutils/native_handle.h&gt;#include &lt;hidl/HidlInternal.h&gt;#include &lt;hidl/HidlSupport.h&gt;namespace android &#123;namespace hardware &#123;typedef uint64_t RingBufferPosition;struct GrantorDescriptor &#123; uint32_t flags __attribute__ ((aligned(4))); uint32_t fdIndex __attribute__ ((aligned(4))); uint32_t offset __attribute__ ((aligned(4))); uint64_t extent __attribute__ ((aligned(8)));&#125;;static_assert(offsetof(GrantorDescriptor, flags) == 0, "wrong offset");static_assert(offsetof(GrantorDescriptor, fdIndex) == 4, "wrong offset");static_assert(offsetof(GrantorDescriptor, offset) == 8, "wrong offset");static_assert(offsetof(GrantorDescriptor, extent) == 16, "wrong offset");static_assert(sizeof(GrantorDescriptor) == 24, "wrong size");static_assert(__alignof(GrantorDescriptor) == 8, "wrong alignment");enum MQFlavor : uint32_t &#123; /* * kSynchronizedReadWrite represents the wait-free synchronized flavor of the * FMQ. It is intended to be have a single reader and single writer. * Attempts to overflow/underflow returns a failure. */ kSynchronizedReadWrite = 0x01, /* * kUnsynchronizedWrite represents the flavor of FMQ where writes always * succeed. This flavor allows one writer and many readers. A read operation * can detect an overwrite and reset the read counter. */ kUnsynchronizedWrite = 0x02&#125;;template &lt;typename T, MQFlavor flavor&gt;struct MQDescriptor &#123; MQDescriptor( const std::vector&lt;GrantorDescriptor&gt;&amp; grantors, native_handle_t* nHandle, size_t size); MQDescriptor(size_t bufferSize, native_handle_t* nHandle, size_t messageSize, bool configureEventFlag = false); MQDescriptor(); ~MQDescriptor(); explicit MQDescriptor(const MQDescriptor &amp;other); MQDescriptor &amp;operator=(const MQDescriptor &amp;other) = delete; size_t getSize() const; size_t getQuantum() const; int32_t getFlags() const; bool isHandleValid() const &#123; return mHandle != nullptr; &#125; size_t countGrantors() const &#123; return mGrantors.size(); &#125; inline const ::android::hardware::hidl_vec&lt;GrantorDescriptor&gt; &amp;grantors() const &#123; return mGrantors; &#125; inline ::android::hardware::hidl_vec&lt;GrantorDescriptor&gt; &amp;grantors() &#123; return mGrantors; &#125; inline const ::native_handle_t *handle() const &#123; return mHandle; &#125; inline ::native_handle_t *handle() &#123; return mHandle; &#125; static const size_t kOffsetOfGrantors; static const size_t kOffsetOfHandle; enum GrantorType : int &#123; READPTRPOS = 0, WRITEPTRPOS, DATAPTRPOS, EVFLAGWORDPOS &#125;; /* * There should at least be GrantorDescriptors for the read counter, write * counter and data buffer. A GrantorDescriptor for an EventFlag word is * not required if there is no need for blocking FMQ operations. */ static constexpr int32_t kMinGrantorCount = DATAPTRPOS + 1; /* * Minimum number of GrantorDescriptors required if EventFlag support is * needed for blocking FMQ operations. */ static constexpr int32_t kMinGrantorCountForEvFlagSupport = EVFLAGWORDPOS + 1; //TODO(b/34160777) Identify a better solution that supports remoting. static inline size_t alignToWordBoundary(size_t length) &#123; constexpr size_t kAlignmentSize = 64; if (kAlignmentSize % __WORDSIZE != 0) &#123; details::logAlwaysFatal("Incompatible word size"); &#125; /* * Check if alignment to word boundary would cause an overflow. */ if (length &gt; SIZE_MAX - kAlignmentSize/8 + 1) &#123; details::logAlwaysFatal("Queue size too large"); &#125; return (length + kAlignmentSize/8 - 1) &amp; ~(kAlignmentSize/8 - 1U); &#125; static inline size_t isAlignedToWordBoundary(size_t offset) &#123; constexpr size_t kAlignmentSize = 64; return (offset &amp; (kAlignmentSize/8 - 1)) == 0; &#125;private: ::android::hardware::hidl_vec&lt;GrantorDescriptor&gt; mGrantors; ::android::hardware::details::hidl_pointer&lt;native_handle_t&gt; mHandle; uint32_t mQuantum; uint32_t mFlags;&#125;;template&lt;typename T, MQFlavor flavor&gt;const size_t MQDescriptor&lt;T, flavor&gt;::kOffsetOfGrantors = offsetof(MQDescriptor, mGrantors);template&lt;typename T, MQFlavor flavor&gt;const size_t MQDescriptor&lt;T, flavor&gt;::kOffsetOfHandle = offsetof(MQDescriptor, mHandle);/* * MQDescriptorSync will describe the wait-free synchronized * flavor of FMQ. */template&lt;typename T&gt;using MQDescriptorSync = MQDescriptor&lt;T, kSynchronizedReadWrite&gt;;/* * MQDescriptorUnsync will describe the unsynchronized write * flavor of FMQ. */template&lt;typename T&gt;using MQDescriptorUnsync = MQDescriptor&lt;T, kUnsynchronizedWrite&gt;;template&lt;typename T, MQFlavor flavor&gt;MQDescriptor&lt;T, flavor&gt;::MQDescriptor( const std::vector&lt;GrantorDescriptor&gt;&amp; grantors, native_handle_t* nhandle, size_t size) : mHandle(nhandle), mQuantum(size), mFlags(flavor) &#123; mGrantors.resize(grantors.size()); for (size_t i = 0; i &lt; grantors.size(); ++i) &#123; if (isAlignedToWordBoundary(grantors[i].offset) == false) &#123; details::logAlwaysFatal("Grantor offsets need to be aligned"); &#125; mGrantors[i] = grantors[i]; &#125;&#125;template&lt;typename T, MQFlavor flavor&gt;MQDescriptor&lt;T, flavor&gt;::MQDescriptor(size_t bufferSize, native_handle_t *nHandle, size_t messageSize, bool configureEventFlag) : mHandle(nHandle), mQuantum(messageSize), mFlags(flavor) &#123; /* * If configureEventFlag is true, allocate an additional spot in mGrantor * for containing the fd and offset for mmapping the EventFlag word. */ mGrantors.resize(configureEventFlag? kMinGrantorCountForEvFlagSupport : kMinGrantorCount); size_t memSize[] = &#123; sizeof(RingBufferPosition), /* memory to be allocated for read pointer counter */ sizeof(RingBufferPosition), /* memory to be allocated for write pointer counter */ bufferSize, /* memory to be allocated for data buffer */ sizeof(std::atomic&lt;uint32_t&gt;)/* memory to be allocated for EventFlag word */ &#125;; /* * Create a default grantor descriptor for read, write pointers and * the data buffer. fdIndex parameter is set to 0 by default and * the offset for each grantor is contiguous. */ for (size_t grantorPos = 0, offset = 0; grantorPos &lt; mGrantors.size(); offset += memSize[grantorPos++]) &#123; mGrantors[grantorPos] = &#123; 0 /* grantor flags */, 0 /* fdIndex */, static_cast&lt;uint32_t&gt;(alignToWordBoundary(offset)), memSize[grantorPos] &#125;; &#125;&#125;template&lt;typename T, MQFlavor flavor&gt;MQDescriptor&lt;T, flavor&gt;::MQDescriptor(const MQDescriptor&lt;T, flavor&gt; &amp;other) : mGrantors(other.mGrantors), mHandle(nullptr), mQuantum(other.mQuantum), mFlags(other.mFlags) &#123; if (other.mHandle != nullptr) &#123; mHandle = native_handle_create( other.mHandle-&gt;numFds, other.mHandle-&gt;numInts); for (int i = 0; i &lt; other.mHandle-&gt;numFds; ++i) &#123; mHandle-&gt;data[i] = dup(other.mHandle-&gt;data[i]); &#125; memcpy(&amp;mHandle-&gt;data[other.mHandle-&gt;numFds], &amp;other.mHandle-&gt;data[other.mHandle-&gt;numFds], other.mHandle-&gt;numInts * sizeof(int)); &#125;&#125;template&lt;typename T, MQFlavor flavor&gt;MQDescriptor&lt;T, flavor&gt;::MQDescriptor() : MQDescriptor( std::vector&lt;android::hardware::GrantorDescriptor&gt;(), nullptr /* nHandle */, 0 /* size */) &#123;&#125;template&lt;typename T, MQFlavor flavor&gt;MQDescriptor&lt;T, flavor&gt;::~MQDescriptor() &#123; if (mHandle != nullptr) &#123; native_handle_close(mHandle); native_handle_delete(mHandle); &#125;&#125;template&lt;typename T, MQFlavor flavor&gt;size_t MQDescriptor&lt;T, flavor&gt;::getSize() const &#123; return mGrantors[DATAPTRPOS].extent;&#125;template&lt;typename T, MQFlavor flavor&gt;size_t MQDescriptor&lt;T, flavor&gt;::getQuantum() const &#123; return mQuantum; &#125;template&lt;typename T, MQFlavor flavor&gt;int32_t MQDescriptor&lt;T, flavor&gt;::getFlags() const &#123; return mFlags; &#125;template&lt;typename T, MQFlavor flavor&gt;std::string toString(const MQDescriptor&lt;T, flavor&gt; &amp;q) &#123; std::string os; if (flavor &amp; kSynchronizedReadWrite) &#123; os += "fmq_sync"; &#125; if (flavor &amp; kUnsynchronizedWrite) &#123; os += "fmq_unsync"; &#125; os += " &#123;" + toString(q.grantors().size()) + " grantor(s), " + "size = " + toString(q.getSize()) + ", .handle = " + toString(q.handle()) + ", .quantum = " + toString(q.getQuantum()) + "&#125;"; return os;&#125;&#125; // namespace hardware&#125; // namespace android#endif // FMSGQ_DESCRIPTOR_H 阻塞队列和事件标记默认情况下，队列不支持阻塞读取/写入。有两种类型的阻塞读取/写入调用： 短格式：有三个参数（数据指针、项数、超时）。支持阻塞针对单个队列的各个读取/写入操作。在使用这种格式时，队列将在内部处理事件标记和位掩码，并且第一个消息队列对象必须初始化为第二个参数为 true。例如： 1234// For an unsynchronized FMQ that supports blockingmFmqUnsynchronizedBlocking = new (std::nothrow) MessageQueue&lt;uint16_t, kUnsynchronizedWrite&gt; (kNumElementsInQueue, true /* enable blocking operations */); 长格式：有六个参数（包括事件标记和位掩码）。支持在多个队列之间使用共享 EventFlag 对象，并允许指定要使用的通知位掩码。在这种情况下，必须为每个读取和写入调用提供事件标记和位掩码。 对于长格式，可在每个 readBlocking() 和 writeBlocking() 调用中显式提供 EventFlag。可以将其中一个队列初始化为包含一个内部事件标记，如果是这样，则必须使用 getEventFlagWord() 从相应队列的 MessageQueue 对象中提取该标记，以用于在每个进程中创建与其他 FMQ 一起使用的 EventFlag 对象。或者，可以将 EventFlag 对象初始化为具有任何合适的共享内存。 一般来说，每个队列都应只使用以下三项之一：非阻塞、短格式阻塞，或长格式阻塞。混合使用也不算是错误；但要获得理想结果，则需要谨慎地进行编程. 使用 MessageQueueMessageQueue 对象的公共 API 是：1234567891011121314151617181920212223242526272829303132size_t availableToWrite() // Space available (number of elements).size_t availableToRead() // Number of elements available.size_t getQuantumSize() // Size of type T in bytes.size_t getQuantumCount() // Number of items of type T that fit in the FMQ.bool isValid() // Whether the FMQ is configured correctly.const MQDescriptor&lt;T, flavor&gt;* getDesc() // Return info to send to other process.bool write(const T* data) // Write one T to FMQ; true if successful.bool write(const T* data, size_t count) // Write count T's; no partial writes.bool read(T* data); // read one T from FMQ; true if successful.bool read(T* data, size_t count); // Read count T's; no partial reads.bool writeBlocking(const T* data, size_t count, int64_t timeOutNanos = 0);bool readBlocking(T* data, size_t count, int64_t timeOutNanos = 0);// Allows multiple queues to share a single event flag wordstd::atomic&lt;uint32_t&gt;* getEventFlagWord();bool writeBlocking(const T* data, size_t count, uint32_t readNotification,uint32_t writeNotification, int64_t timeOutNanos = 0,android::hardware::EventFlag* evFlag = nullptr); // Blocking write operation for count Ts.bool readBlocking(T* data, size_t count, uint32_t readNotification,uint32_t writeNotification, int64_t timeOutNanos = 0,android::hardware::EventFlag* evFlag = nullptr) // Blocking read operation for count Ts;//APIs to allow zero copy read/write operationsbool beginWrite(size_t nMessages, MemTransaction* memTx) const;bool commitWrite(size_t nMessages);bool beginRead(size_t nMessages, MemTransaction* memTx) const;bool commitRead(size_t nMessages); availableToWrite() 和 availableToRead() 可用于确定在一次操作中可传输的数据量。在未同步队列中： availableToWrite() 始终返回队列容量。 每个读取器都有自己的读取位置，并会针对 availableToRead() 进行自己的计算。 如果是读取速度缓慢的读取器，队列可以溢出，这可能会导致 availableToRead() 返回的值大于队列的大小。发生溢出后进行的第一次读取操作将会失败，并且会导致相应读取器的读取位置被设为等于当前写入指针，无论是否通过 availableToRead() 报告了溢出都是如此。 如果所有请求的数据都可以（并已）传输到队列/从队列传出，则 read() 和 write() 方法会返回 true。这些方法不会阻塞；它们要么成功（并返回 true），要么立即返回失败 (false)。 readBlocking() 和 writeBlocking() 方法会等到可以完成请求的操作，或等到超时（timeOutNanos 值为 0 表示永不超时）。 阻塞操作使用事件标记字词来实现。默认情况下，每个队列都会创建并使用自己的标记字词来支持短格式的 readBlocking() 和 writeBlocking()。多个队列可以共用一个字词，这样一来，进程就可以等待对任何队列执行写入或读取操作。可以通过调用 getEventFlagWord() 获得指向队列事件标记字词的指针，此类指针（或任何指向合适的共享内存位置的指针）可用于创建 EventFlag 对象，以传递到其他队列的长格式 readBlocking() 和 writeBlocking()。readNotification 和 writeNotification 参数用于指示事件标记中的哪些位应该用于针对相应队列发出读取和写入信号。readNotification 和 writeNotification 是 32 位的位掩码。 readBlocking() 会等待 writeNotification 位；如果该参数为 0，则调用一定会失败。如果 readNotification 值为 0，则调用不会失败，但成功的读取操作将不会设置任何通知位。在已同步队列中，这意味着相应的 writeBlocking() 调用一定不会唤醒，除非已在其他位置对相应的位进行设置。在未同步队列中，writeBlocking() 将不会等待（它应仍用于设置写入通知位），而且对于读取操作来说，不适合设置任何通知位。同样，如果 readNotification 为 0，writeblocking() 将会失败，并且成功的写入操作会设置指定的 writeNotification 位。 要一次等待多个队列，请使用 EventFlag 对象的 wait() 方法来等待通知的位掩码。wait() 方法会返回一个状态字词以及导致系统设置唤醒的位。然后，该信息可用于验证相应的队列是否有足够的控件或数据来完成所需的写入/读取操作，并执行非阻塞 write()/read()。要获取操作后通知，请再次调用 EventFlag 的 wake() 方法。有关 EventFlag 抽象的定义，请参阅system/libfmq/include/fmq/EventFlag.hEventFlag.h内容如下所示：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/* * Copyright (C) 2016 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */#ifndef HIDL_EVENTFLAG_H#define HIDL_EVENTFLAG_H#include &lt;time.h&gt;#include &lt;utils/Errors.h&gt;#include &lt;atomic&gt;namespace android &#123;namespace hardware &#123;/** * EventFlag is an abstraction that application code utilizing FMQ can use to wait on * conditions like full, empty, data available etc. The same EventFlag object * can be used with multiple FMQs. */struct EventFlag &#123; /** * Create an event flag object with mapping information. * * @param fd File descriptor to be mmapped to create the event flag word. * There is no transfer of ownership of the fd. The caller will still * own the fd for the purpose of closing it. * @param offset Offset parameter to mmap. * @param ef Pointer to address of the EventFlag object that gets created. Will be set to * nullptr if unsuccesful. * * @return status Returns a status_t error code. Likely error codes are * NO_ERROR if the method is successful or BAD_VALUE due to invalid * mapping arguments. */ static status_t createEventFlag(int fd, off_t offset, EventFlag** ef); /** * Create an event flag object from the address of the flag word. * * @param efWordPtr Pointer to the event flag word. * @param status Returns a status_t error code. Likely error codes are * NO_ERROR if the method is successful or BAD_VALUE if efWordPtr is a null * pointer. * @param ef Pointer to the address of the EventFlag object that gets created. Will be set to * nullptr if unsuccesful. * * @return Returns a status_t error code. Likely error codes are * NO_ERROR if the method is successful or BAD_VALUE if efAddr is a null * pointer. * */ static status_t createEventFlag(std::atomic&lt;uint32_t&gt;* efWordPtr, EventFlag** ef); /** * Delete an EventFlag object. * * @param ef A double pointer to the EventFlag object to be destroyed. * * @return Returns a status_t error code. Likely error codes are * NO_ERROR if the method is successful or BAD_VALUE due to * a bad input parameter. */ static status_t deleteEventFlag(EventFlag** ef); /** * Set the specified bits of the event flag word here and wake up a thread. * @param bitmask The bits to be set on the event flag word. * * @return Returns a status_t error code. Likely error codes are * NO_ERROR if the method is successful or BAD_VALUE if the bit mask * does not have any bits set. */ status_t wake(uint32_t bitmask); /** * Wait for any of the bits in the bit mask to be set. * * @param bitmask The bits to wait on. * @param timeoutNanoSeconds Specifies timeout duration in nanoseconds. It is converted to * an absolute timeout for the wait according to the CLOCK_MONOTONIC clock. * @param efState The event flag bits that caused the return from wake. * @param retry If true, retry automatically for a spurious wake. If false, * will return -EINTR or -EAGAIN for a spurious wake. * * @return Returns a status_t error code. Likely error codes are * NO_ERROR if the method is successful, BAD_VALUE due to bad input * parameters, TIMED_OUT if the wait timedout as per the timeout * parameter, -EAGAIN or -EINTR to indicate that the caller needs to invoke * wait() again. -EAGAIN or -EINTR error codes will not be returned if * 'retry' is true since the method will retry waiting in that case. */ status_t wait(uint32_t bitmask, uint32_t* efState, int64_t timeOutNanoSeconds = 0, bool retry = false);private: bool mEfWordNeedsUnmapping = false; std::atomic&lt;uint32_t&gt;* mEfWordPtr = nullptr; /* * mmap memory for the event flag word. */ EventFlag(int fd, off_t offset, status_t* status); /* * Use this constructor if we already know where the event flag word * lives. */ EventFlag(std::atomic&lt;uint32_t&gt;* efWordPtr, status_t* status); /* * Disallow constructor without argument and copying. */ EventFlag(); EventFlag&amp; operator=(const EventFlag&amp; other) = delete; EventFlag(const EventFlag&amp; other) = delete; /* * Wait for any of the bits in the bit mask to be set. */ status_t waitHelper(uint32_t bitmask, uint32_t* efState, int64_t timeOutNanoSeconds); /* * Utility method to unmap the event flag word. */ static status_t unmapEventFlagWord(std::atomic&lt;uint32_t&gt;* efWordPtr, bool* efWordNeedsUnmapping); /* * Utility method to convert timeout duration to an absolute CLOCK_MONOTONIC * clock time which is required by futex syscalls. */ inline void addNanosecondsToCurrentTime(int64_t nanoseconds, struct timespec* timeAbs); ~EventFlag();&#125;;&#125; // namespace hardware&#125; // namespace android#endif 零复制操作read/write/readBlocking/writeBlocking() API 会将指向输入/输出缓冲区的指针作为参数，并在内部使用 memcpy() 调用，以便在相应缓冲区和 FMQ 环形缓冲区之间复制数据。为了提高性能，Android 8.0 及更高版本包含一组 API，这些 API 可提供对环形缓冲区的直接指针访问，这样便无需使用 memcpy 调用。 使用以下公共 API 执行零复制 FMQ 操作：12345bool beginWrite(size_t nMessages, MemTransaction* memTx) const;bool commitWrite(size_t nMessages);bool beginRead(size_t nMessages, MemTransaction* memTx) const;bool commitRead(size_t nMessages); beginWrite 方法负责提供用于访问 FMQ 环形缓冲区的基址指针。在数据写入之后，使用 commitWrite() 提交数据。beginRead/commitRead 方法的运作方式与之相同。 beginRead/Write 方法会将要读取/写入的消息条数视为输入，并会返回一个布尔值来指示是否可以执行读取/写入操作。如果可以执行读取或写入操作，则 memTx 结构体中会填入基址指针，这些指针可用于对环形缓冲区共享内存进行直接指针访问。 MemRegion 结构体包含有关内存块的详细信息，其中包括基础指针（内存块的基址）和以 T 表示的长度（以 HIDL 定义的消息队列类型表示的内存块长度）。 MemTransaction 结构体包含两个 MemRegion 结构体（first 和 second），因为对环形缓冲区执行读取或写入操作时可能需要绕回到队列开头。这意味着，要对 FMQ 环形缓冲区执行数据读取/写入操作，需要两个基址指针。 从 MemRegion 结构体获取基址和长度：123T* getAddress(); // gets the base addresssize_t getLength(); // gets the length of the memory region in terms of Tsize_t getLengthInBytes(); // gets the length of the memory region in bytes 获取对 MemTransaction 对象内的第一个和第二个 MemRegion 的引用：12const MemRegion&amp; getFirstRegion(); // get a reference to the first MemRegionconst MemRegion&amp; getSecondRegion(); // get a reference to the second MemRegion 使用零复制 API 写入 FMQ 的示例：1234567891011121314MessageQueueSync::MemTransaction tx;if (mQueue-&gt;beginRead(dataLen, &amp;tx)) &#123; auto first = tx.getFirstRegion(); auto second = tx.getSecondRegion(); foo(first.getAddress(), first.getLength()); // method that performs the data write foo(second.getAddress(), second.getLength()); // method that performs the data write if(commitWrite(dataLen) == false) &#123; // report error &#125;&#125; else &#123; // report error&#125; 以下辅助方法也是 MemTransaction 的一部分： T* getSlot(size_t idx);返回一个指针，该指针指向属于此 MemTransaction 对象一部分的 MemRegions 内的槽位 idx。如果 MemTransaction 对象表示要读取/写入 N 个类型为 T 的项目的内存区域，则 idx 的有效范围在 0 到 N-1 之间。 bool copyTo(const T* data, size_t startIdx, size_t nMessages = 1);将 nMessages 个类型为 T 的项目写入到该对象描述的内存区域，从索引 startIdx 开始。此方法使用 memcpy()，但并非旨在用于零复制操作。如果 MemTransaction 对象表示要读取/写入 N 个类型为 T 的项目的内存区域，则 idx 的有效范围在 0 到 N-1 之间。 bool copyFrom(T* data, size_t startIdx, size_t nMessages = 1);一种辅助方法，用于从该对象描述的内存区域读取 nMessages 个类型为 T 的项目，从索引 startIdx 开始。此方法使用 memcpy()，但并非旨在用于零复制操作。 通过 HIDL 发送队列在创建侧执行的操作： 创建消息队列对象，如上所述。 使用 isValid() 验证对象是否有效。 如果您要通过将 EventFlag 传递到长格式的 readBlocking()/writeBlocking() 来等待多个队列，则可以从经过初始化的 MessageQueue 对象提取事件标记指针（使用 getEventFlagWord()）以创建标记，然后使用该标记创建必需的 EventFlag 对象。 使用 MessageQueue getDesc() 方法获取描述符对象。 在 .hal 文件中，为某个方法提供一个类型为 fmq_sync 或 fmq_unsync 的参数，其中 T 是 HIDL 定义的一种合适类型。使用此方法将 getDesc() 返回的对象发送到接收进程。 在接收侧执行的操作： 使用描述符对象创建 MessageQueue 对象。务必使用相同的队列风格和数据类型，否则将无法编译模板。 如果您已提取事件标记，则在接收进程中从相应的 MessageQueue 对象提取该标记。 使用 MessageQueue 对象传输数据。 google原文地址]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>HIDL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIDL C++]]></title>
    <url>%2F2018%2F01%2F29%2FHIDL-C%2F</url>
    <content type="text"><![CDATA[Android O上porting HAL，一定要看这个文档 Android O 对 Android 操作系统的架构重新进行了设计，以在独立于设备的 Android 平台与特定于设备和供应商的代码之间定义清晰的接口。Android 已经以 HAL 接口的形式（在 hardware/libhardware 中定义为 C 标头）定义了许多此类接口。HIDL 将这些 HAL 接口替换为稳定的带版本接口，它们可以是采用 C++（如下所述）或 Java 的客户端和服务器端 HIDL 接口。 本部分中的几页内容介绍了 HIDL 接口的 C++ 实现，其中详细说明了 hidl-gen 编译器基于 HIDL .hal 文件自动生成的文件，这些文件如何打包，以及如何将这些文件与使用它们的 C++ 代码集成。 客户端和服务器实现HIDL 接口具有客户端和服务器实现： HIDL 接口的客户端实现是指通过在该接口上调用方法来使用该接口的代码。 服务器实现是指 HIDL 接口的实现，它可接收来自客户端的调用并返回结果（如有必要）。 在从 libhardware HAL 转换为 HIDL HAL 的过程中，HAL 实现成为服务器，而调用 HAL 的进程则成为客户端。默认实现可提供直通和绑定式 HAL，并可能会随着时间而发生变化： 创建 HAL 客户端首先将 HAL 库添加到 makefile 中： Make：LOCAL_SHARED_LIBRARIES += android.hardware.nfc@1.0 Soong：shared_libs: [ …, android.hardware.nfc@1.0 ] 接下来，添加 HAL 头文件： 12345#include &lt;android/hardware/nfc/1.0/IFoo.h&gt;…// in code:sp&lt;IFoo&gt; client = IFoo::getService();client-&gt;doThing(); 创建 HAL 服务器要创建 HAL 实现，您必须具有表示 HAL 的 .hal 文件并已在 hidl-gen 上使用 -Lmakefile 或 -Landroidbp 为 HAL 生成makefile（./hardware/interfaces/update-makefiles.sh 会为内部 HAL 文件执行这项操作，这是一个很好的参考）。从 libhardware 通过 HAL 传输时，您可以使用 c2hal 轻松完成许多此类工作。 创建必要的文件来实现您的 HAL： 1234567PACKAGE=android.hardware.nfc@1.0LOC=hardware/interfaces/nfc/1.0/default/make hidl-gen -j64hidl-gen -o $LOC -Lc++-impl -randroid.hardware:hardware/interfaces \ -randroid.hidl:system/libhidl/transport $PACKAGEhidl-gen -o $LOC -Landroidbp-impl -randroid.hardware:hardware/interfaces \ -randroid.hidl:system/libhidl/transport $PACKAGE 为了让 HAL 在直通模式下发挥作用（对于旧版设备），您必须具有 HIDL_FETCH_IModuleName 函数（位于 /system/lib(64)?/hw/android.hardware.package@3.0-impl($OPTIONAL_IDENTIFIER).so 下），其中 $OPTIONAL_IDENTIFIER 是一个用于标识直通实现的字符串。直通模式要求会通过上述命令自动满足，这些命令也可用于创建 android.hardware.nfc@1.0-impl 目标，但是可以使用扩展。例如，android.hardware.nfc@1.0-impl-foo 就是使用 -foo 来区分它自己。 接下来，使用相应功能填写存根并设置守护进程。守护进程代码（支持直通）示例： 123456789101112131415#include &lt;hidl/LegacySupport.h&gt;int main(int /* argc */, char* /* argv */ []) &#123; return defaultPassthroughServiceImplementation&lt;INfc&gt;("nfc");&#125;defaultPassthroughServiceImplementation 将对提供的 -impl 库执行 dlopen() 操作，并将其作为绑定式服务提供。守护进程代码（对于纯绑定式服务）示例：int main(int /* argc */, char* /* argv */ []) &#123; Nfc nfc = new Nfc(); const status_t status = nfc-&gt;registerAsService(); if (status != ::android::OK) &#123; return 1; // or handle error &#125; // join pool or do other things&#125; 此守护进程应该存在于 $PACKAGE + “-service”（例如 android.hardware.nfc@1.0-service）中。HAL 的特定类的 sepolicy 是属性 hal_（例如 hal_nfc)）。您必须将此属性应用到运行特定 HAL 的守护进程（如果同一进程提供多个 HAL，则可以将多个属性应用到该进程）。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>HIDL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Https劫持]]></title>
    <url>%2F2018%2F01%2F23%2FhttpsHijack%2F</url>
    <content type="text"><![CDATA[HTTPS是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL 传统的https是基于PKI体系的，需要公钥和私钥来通信，这里不讨论证书被盗的问题。利用诸如sslstrip之类的技术，这里sslstrip相当于一个代理，你提交的数据都会经过这个代理，sslstrip会将提交的https加密信息转为http进行截获保存，然后在将页面返回给正常用户，显示的是https，这个过程在你肉眼看来是基本无法判断的。 SSLStripSSLstrip 也叫 https 降级攻击，攻击者拦截用户流量后，欺骗用户与攻击者进行 http 通信，攻击者与服务器保持正常通信 （http 或 https），从而获取用户信息。 通过中间人攻击监听 http 流量（自己试验可以通过设置 http 代理） 更改重定向链接中的 location，替换 https 为 http，并记录 更改响应内容中的超链接，替换 https 为 http，并记录 与用户进行 http 通信，与服务器进行 https 通信（记录中本应是 https 的请求），从而明文获取用户信息 环境搭建 代码获取git clone git@github.com:zsky/sslstrip.git 依赖安装 Nodejs 安装 dsniffsudo apt-get install dsniff 安装 nmapsudo apt-get install nma 查点背景为内网，仅作为演示 扫描主机使用nmap命令扫描局域网，获得主机列表如果所在局域网路由器地址是 192.168.16.1,可以使用 nmap -sP 192.168.16.1/24 扫描-sP 表示使用 ping 方式扫描，192.168.16.1/24”表示扫描”192.168.16.1-192.168.16.254”这个网段的所有机器。 开启IP转发ARP欺骗一般目的是把自己伪装成网关，但如果不作处理，当被欺骗数据包到达后就会被本机丢弃（因为本机不是网关，不知道如何处理这类数据包），这当然是不允许的。开启IP转发功能可以解决该问题，IP转发负责把该类数据包再转发给真正的网关处理，开启IP转发的方法：echo1 &gt;/proc/sys/net/ipv4/ip_forward ARP 欺骗假设被攻击的 IP 是 192.168.16.134，局域网的网关是 192.168.16.1，攻击电脑使用的网卡接口是 en0(可以使用 ifconfig 命令查看）, 则欺骗命令如下：arpspoof -i en0 -t 192.168.16.134 192.168.16.1 数据分析如果 ARP 欺骗成功，则被攻击的设备会把所有数据先传到我们电脑上，接下来可以使用 wireshark 软件来分析数据。至此，中间人攻击完成，接下来可以开始进行 SSLstrip 攻击。 ## 攻击 启动ssltrip命令行进入 sslstrip 程序的根目录，输入命令 node index.js可以看到程序监听的端口号，比如 80 将流量导入sslstrip 修改IP转发iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080为sslstrip的监听端口号 删除记录iptables -t nat -D PREROUTING 1 查看ip转发表iptables -t nat -L sslstrip 输出sslstrip会把https的post请求的数据输出到终端]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>HTTPS sslstrip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SecureBoot]]></title>
    <url>%2F2018%2F01%2F22%2Fsecureboot%2F</url>
    <content type="text"><![CDATA[使一个人值得信任的唯一方法就是信任他。——杰弗逊 概述使一个人值得信任的唯一方法就是信任他，使一台设备值得信任要靠信任链。 这个信任链要靠层层验证来实现，它的核心是一个证书链：rootCA--&gt;attestationCA certificate--&gt;attestationCArootCA 保存着给attestationCA certificate验证签名的public keyattestationCA certificate 保存这给attestationCA验证签名的公钥attestationCA保存着给镜像验证签名的公钥rootCA的签名保存在ROM中，设备启动的时候第一阶段Bootloader(它在ROM中)，计算rootCA的签名，和存在ROM中的签名对比，如果相同，那么rootCA有效,以此类推最终验证image. UEFI Secure BootPKPlatform Key 在平台拥有者和平台固件之间建立可信关系。 KEKKey Exchange Key 包含可信实体的公共证书，这个证书被允许去配置数据库的Allowed和Forbidden db/dbxAllowed/Forbidden database 包含多个被allowed/disallowed的modules和signed images的可信实体的public certificates]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>SecureBoot certlink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android8.0的Selinux]]></title>
    <url>%2F2018%2F01%2F21%2FAndroid80Selinux%2F</url>
    <content type="text"><![CDATA[积极的人在每一次忧患中都看到一个机会， 而消极的人则在每个机会都看到某种忧患 这个文档描述SELinux的修改和定制设计来支持Ａndroid 8.0的SELinux policy的模块化和可更新性。这些修改的目标是让ＳoC和ODM能够彼此独立的定制SELinux的设置 在Android4.4到7.0版本，SELinux policy的建立流程（build flow）是在code里被分成平台和非平台的２部分，然后在root dir里面生成一个文件.因此这个流程违背了Ａndroid的主要目标，就是各个部分的所有者可以独立更新他们自己那部分的policy,建立他们自己的images,例如vendor.img的维护者修改vendor相关的policy,boot.img的拥有者修改boot相关的policy,他们之间互补干扰。 Ａndroid 8.0的设计目标 Policy ​Modularization Policy ​Compatibility ● system.img. ​Contains ​mainly ​Android ​framework. ● boot.img. ​(kernel/ramdisk) ​Contains ​Linux ​kernel ​+ ​Android ​patches. ● vendor.img. ​Contains ​SoC-specific ​code ​and ​configurations. ● odm.img. ​Contains ​device-specific ​code ​and ​configurations. ● oem.img. ​Contains ​OEM/carrier-related ​configurations ​and ​customizations. ● bootloader. ​Brings ​up ​the ​kernel ​(vendor-proprietary). ● radio. ​Modem ​(proprietary).在Android8.0之前，vendor,odm,和oem镜像是可选的；在缺省状态下，被编译到这些镜像中的文件,其实被放置到boot.img或者system.img，他们只是符号链接，例如： vendor -&gt; /system/vendor。而在８.0之后这些分区镜像将被强制划分。 模块化android分区的目的是，使用一组定义在android 平台和制造商代码之间的核心，标准接口，让模块可以各自的被替换。这个标准接口能使android平台在不对SoC和ＯDM分区产生副作用的情况下被更新。例如，可以让设备的system.img从Android 8.0升级到Android P，而其他分区仍然保持Android 8.0。这种模块化的好处是使Ａndroid平台的更新更实时了，因为更新的时候不再需要请求Ｓoc/ODM去更新Ｓoc和设备相关的代码了，例如每个月安全更新。 Android 8.0 SELinux设计First stage mount8.0以前的就不说了,在８.0版本，作为模块化的SELinux policy文件将被存储在各自的分区中，例如vendor里面保存的是vendor的SELinux policy,在设备启动阶段，init进程中必须挂在system和vendor分区，所以它可以读取这些分区中的SELinux 文件，然后把他们合成一个SELinux 文件，并放到system目录下。 SELinux 上下文标签File contexts 为避免在boot阶段额外的编译，file_contexts 不在被放到二进制文件中了，取而代之的是，它们是刻度的，正则的文本文件，像： ｛property,service｝_contexts file_contexts被分割成２个文件： Plat_file_contexts Android platform的file_context，它不包含设备相关的labels,除了/vendor分区的必须被精确标记的确保平台相应的功能的labeling parts，例如：sepolicy files 必须存在于设备上的system分区的/system/etc/selinux/plat_file_contexts目录中，必须要在启动阶段，被init和non-platform file_context一起加载。 Nonplat_file_contexts 设备相关的file_context由多个子file_context组合生成，子ile_context在定义在设备的Boardconfig.mk文件中的BOARD_SEPOLICY_DIRS指定的目录下。 必须被放置在设备vendor分区的/vendor/etc/selinux/nonplat_file_contexts下，必须在设备启动阶段，和platform_file_context一起被init加载。 Property contextsproperty_contexts和file_contexts一样也是被分成２部分，放置位置和加载规则,yi以及命名规则参考file_contexts原文如下：​the property_contexts ​is ​split ​between ​two ​files: plat_property_contexts Android ​platform property_context ​that ​has ​no ​device-specific ​labels. Must ​reside ​in system ​partition ​at /system/etc/selinux/plat_property_contexts ​and ​be ​loaded ​by init ​at the ​start ​along ​with ​the ​non-platform property_contexts. nonplat_property_contexts Device-specific property_context ​built ​by ​combining property_contexts found ​in ​the ​directories ​pointed ​to ​by BOARD_SEPOLICY_DIRS ​in ​device’s Boardconfig.mk ​files. Must ​reside ​in vendor ​partition ​at /vendor/etc/selinux/nonplat_property_contexts ​and ​be ​loaded ​by init at ​the ​start ​along ​with ​the ​platform property_context Service conexts与其他的不同 seapp contextsthe seapp_contexts ​is ​split ​between ​two ​files: plat_seapp_contexts Android ​platform seapp_context ​that ​has ​no ​device-specific ​changes. Must ​reside ​in system ​partition ​at /system/etc/selinux/plat_seapp_contexts. nonplat_seapp_contexts Device-specific ​extension ​to ​platform seapp_context ​built ​by ​combining seapp_contexts ​found ​in ​the ​directories ​pointed ​to ​by BOARD_SEPOLICY_DIRS in ​the ​device’s Boardconfig.mk ​files. Must ​reside ​in vendor ​partition ​at /vendor/etc/selinux/nonplat_seapp_contexts. MAC permissions对象的所属关系和打标签Type/attribute namespaceing 为了避免重名，非平台相关的声明都要加上前缀”np_” 1type foo, domain; → type np_foo, domain; System ​Property ​and ​process ​labeling ​ownership 为了避免标签冲突，Vendors应该加上前缀”np_” 123foo.xxx → np.foo.xxxro.foo.xxx → ro.np.foo.xxxpersist.foo.xxx → persist.np.foo.xxx File ​ownership System(/system)system镜像的labels只能通过file_contexts, service_contexts 等等提供给/system组件。如果给/system组件的标签被添加到了/vendor的policy,那么framework-only OTA升级将是不可能的。 Vendor(/vendor) 单击Android 8.0 SElinux 下载Google官方文档]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>selinux android8.0 MAC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代加密]]></title>
    <url>%2F2018%2F01%2F16%2FModernEncrypto%2F</url>
    <content type="text"><![CDATA[希望是典型的人类妄想，它既是人类强大力量的来源，也造就了人类最大的弱点。 1.加密数据按照优先级,应该选择:(1) 首选 NaCl库,或者libsodium库,使用里面的crypto_secretbox()/crypto_secretbox_open() 函数(2) Chacha20-Poly1305 算法 适用场景:当你需要避免把明文数据在网络上传输的时候。以上3种算法,都是AEAD类的算法,AEAD是2015年最好的选择。 其中的(2)和(3)在 结构上类似:一个流加密模式的算法,配合一个多项式结构的MAC.(2)是一个流加密算法,配合一 个为通用cpu优化的MAC算法,对密码学库的实现者来说,Poly1305也比GCM更容易安全地实现。AES-GCM是工业标准(TLS目前主要用的就是AES-GCM),现代CPU通常都有专门为AES-GCM设计的硬件指令,但是在没有硬件指令支持的CPU上(比如32位的arm)(3)性能低于(2)。 注意避免: 避免AES-CBC(说来话长,后文有解释) 避免AES-CTR 避免64bit块大小的块加密算法—(说的就是你—BlowFish) 避免OFB模式 不要使用RC4,RC4已经被攻破 2.对称密钥长度选择使用256bit长度的密钥 适用场景：只要你在使用密码学，你就应该注意对称密钥长度 注意：不要把堆成密钥的Key长度，和非对称加密的key长度搞混了，堆成密钥的key通常比非对称加密的key短很多。 下表对比了相同安全程度时，不同算法的密钥长度，单位：bit Symmetric ECC DH/DSA/RSA 80 163 1024 112 233 2048 128 283 3072 192 409 7680 256 571 15360 此外，应该避免 避免使用巨大key的算法(使用远大于256的key,只能说明使用者没有安全概念) 避免把多个加密算法串联叠加起来使用,这并没有什么卵用 避免128bit以下的key长度(比如,哥们求你别再提DES这种56bit密钥的古董了) 3.对称签名应该选择HMAC类的算法 适用场景:安全加固一个API,如各种开放API的调用方认证.如果对一个API,你需要做认证(authenticating),但是不需要做加密(encrypting),记得千万不要自己发明算法,你自己发明的MAC算法基本都有安全漏洞,如果不信,请Google一下 “长度扩展攻击” (长度扩展攻击Flickr的漏洞案例).同时,必须要注意的是,要使用一个常数时间字符串对比算法(这个地方和码农的常识完全相反,请务必留意) 此外,应该 避免自行设计的“带密码的hash”结构,你的设计基本都是有安全漏洞的 避免HMAC-MD5,避免HMAC-SHA1,使用HMAC-SHA256, HMAC-SHA512等 避免复杂的多项式MAC 避免加密hash值的结构 避免CRC 4.Hashing/HMAC算法应该选择SHA2类的算法:SHA-256,SHA-384,SHA-512,SHA-512/256优先使用SHA-512/256,SHA-512/256 这个算法把SHA-512的512bit输出截短到256bit,避开了length extension 攻击。同时,目前 SHA-2 是很安全可靠的,你不需要升级到 SHA-3 . 此外,应该 避免SHA-1 避免MD5 避免MD6 5.随机ID应该使用256 bit的随机值一定要使用/dev/urandom,请认准这个 此外,应该 避免用户空间的随机数生成器如:havaged,prngs,egd等 避免/dev/random]]></content>
      <categories>
        <category>密码学应用</category>
      </categories>
      <tags>
        <tag>security crypto</tag>
      </tags>
  </entry>
</search>
